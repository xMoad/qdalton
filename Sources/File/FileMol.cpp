/**********************************************************************
  Copyright (C) 2008, 2009, 2010 Anton Simakov

  This file is part of QDalton.
  For more information, see <http://code.google.com/p/qdalton/>

  QDalton is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  QDalton is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with QDalton. If not, see <http://www.gnu.org/licenses/>.

 **********************************************************************/

#include <QCoreApplication>
#include <QFile>
#include <QTextStream>

#include "File/FileMol.h"
#include "File/FileText.h"

File::Mol::Mol() :
    File::Text(),
    molecule_(),
    generalStringIndex_(4),
    basisType_("BASIS"),
    basisSet_("6-31G*"),
    comment_(QString("Comment line\nAutomaticly generated by %1 %2").arg(
        QCoreApplication::applicationName(),
        QCoreApplication::applicationVersion())),
    atomTypes_(0),
    unitOfLength_(UnitOfLengthBohr),
    gaussiansType_(GaussiansTypeSpherical),
    generatorsCount_(0),
    generators_(),
    hashBasisSets_()
{
}

File::Mol::Mol(const Render::Molecule& molecule) :
    File::Text(),
    molecule_(molecule),
    generalStringIndex_(4),
    basisType_("BASIS"),
    basisSet_("6-31G*"),
    comment_(QString("Comment line\nAutomaticly generated by %1 %2").arg(
        QCoreApplication::applicationName(),
        QCoreApplication::applicationVersion())),
    atomTypes_(0),
    unitOfLength_(UnitOfLengthBohr),
    gaussiansType_(GaussiansTypeSpherical),
    generatorsCount_(0),
    generators_(),
    hashBasisSets_()
{
}

File::Mol::Mol(const File::Mol& fileMol) :
    File::Text(fileMol),
    molecule_(fileMol.molecule_),
    generalStringIndex_(fileMol.generalStringIndex_),
    basisType_(fileMol.basisType_),
    basisSet_(fileMol.basisSet_),
    comment_(fileMol.comment_),
    atomTypes_(fileMol.atomTypes_),
    unitOfLength_(fileMol.unitOfLength_),
    gaussiansType_(fileMol.gaussiansType_),
    generatorsCount_(fileMol.generatorsCount_),
    generators_(fileMol.generators_),
    hashBasisSets_(fileMol.hashBasisSets_)
{
  std::cout << std::endl;
}

//File::Mol& File::Mol::operator=(const File::Mol& rhs)
//                               {
//  //TODO!
//}

Render::Molecule& File::Mol::molecule()
{
  return molecule_;
}

//void File::Mol::setMolecule(const Render::Molecule& molecule)
//{
//  molecule_ = molecule;
//}

bool File::Mol::parse(bool doAutoRebond)
{
  if (parseBasis())
    if (parseGeneralString())
      if (parseAtoms())
      {
    if (doAutoRebond)
    {
      molecule().rebond();
    }
    return true;
  }

  return false;
}

bool File::Mol::generate()
{
  int atomTypes = 0;
  float x, y, z;

  clear();

  addString(basisType_);
  addString(basisSet_);
  addString(comment_);

  QList<Render::Atom*> atomsList;

  for (quint16 i = 0; i < molecule().atomsCount(); ++i)
  {
    atomsList << &molecule().atom(i);
  }

  while (atomsList.count() > 0)
  {
    QList<Render::Atom*> atomsOfTheSameTypeList;
    atomsOfTheSameTypeList << atomsList.takeFirst();
    quint8 charge = atomsOfTheSameTypeList[0]->atomicNumber();
    int n = atomsList.count();
    int i = 0;
    while (i < n)
    {
      if (atomsList[i]->atomicNumber() == charge)
      {
        atomsOfTheSameTypeList << atomsList.takeAt(i);
        n--;
      }
      else
      {
        i++;
      }
    }

    QString atomsOfTheSameTypeHeader = QString("Charge=%1 Atoms=%2").arg(
        charge).arg(atomsOfTheSameTypeList.count());

    if (basisType_ == "ATOMBASIS")
      atomsOfTheSameTypeHeader += QString(" Basis=%1").arg(
          hashBasisSets_[charge]);

    addString(atomsOfTheSameTypeHeader);

    for (quint16 i = 0; i < atomsOfTheSameTypeList.count(); ++i)
    {
      x = atomsOfTheSameTypeList[i]->centre().x();
      y = atomsOfTheSameTypeList[i]->centre().y();
      z = atomsOfTheSameTypeList[i]->centre().z();

      if (unitOfLength() == UnitOfLengthBohr)
      {
        x = x / bohrsToAngstroms;
        y = y / bohrsToAngstroms;
        z = z / bohrsToAngstroms;
      }

      QString temp = QString("%1%2\t%3%4%5").arg(
          atomsOfTheSameTypeList[i]->symbol()).arg(
              i + 1).arg(
                  x, 12, 'f', 6).arg(
                      y, 12, 'f', 6).arg(
                          z, 12, 'f', 6);

      if (atomsOfTheSameTypeList[i]->isotope() != 0)
        temp += QString("\tIsotope=%1").arg(atomsOfTheSameTypeList[i]->isotope());

      addString(temp);
    }
    atomTypes++;
  }

  setAtomTypes(atomTypes);

  QString generalString(QString("Atomtypes=%1").arg(atomTypes));

  if (unitOfLength() == UnitOfLengthAngstrom)
    generalString.append(" Angstrom");

  if (molecule().charge() != 0)
    generalString.append(QString(" Charge=%1").arg(molecule().charge()));

  if (gaussiansType() == GaussiansTypeCartesian)
    generalString.append(" Cartesian");

  insertString(generalStringIndex_ - 1, generalString);

  return true;
}

const QString& File::Mol::comment() const
{
  return comment_;
}

int File::Mol::atomTypes() const
{
  return atomTypes_;
}

void File::Mol::setAtomTypes(int atomTypes)
{
  atomTypes_ = atomTypes;
}

UnitOfLength File::Mol::unitOfLength() const
{
  return unitOfLength_;
}

void File::Mol::setUnitOfLength(UnitOfLength unitOfLength)
{
  unitOfLength_ = unitOfLength;
}

GaussiansType File::Mol::gaussiansType() const
{
  return gaussiansType_;
}

void File::Mol::setGaussiansType(GaussiansType gaussiansType)
{
  gaussiansType_ = gaussiansType;
}

bool File::Mol::parseBasis()
{
  QStringList basisTypesStringList;
  basisTypesStringList << "ATOMBASIS" << "BASIS" << "INTGRL";


  if (basisTypesStringList.contains(string(0).trimmed()))
  {
    basisType_ = string(0).trimmed();
    // Depending on basis type do some actions and set the number of general string.
    if (basisType_ == "BASIS")
    {
      comment_ = string(2) + "\n" + string(3);
      generalStringIndex_ = 4;
    }
    else
    {
      comment_ = string(1) + "\n" + string(2);
      generalStringIndex_ = 3;
    }
    return true;
  }
  else
  {
    setParseError(0, "Unknown basis type: " + string(0));
    return false;
  }
}

bool File::Mol::parseGeneralString()
{
  int n = 0;
  bool ok;
  QRegExp regExp;

  regExp.setPattern("Atomtypes=(\\d+)");
  n = regExp.indexIn(string(generalStringIndex_));
  if (n != -1)
  {
    setAtomTypes(regExp.cap(1).toInt(&ok, 10));
  }
  else
  {
    setParseError(generalStringIndex_,
             "Couldn't find Atomtypes keyword.\n\n"
             "Hint: QDalton 0.1 recognizes only full names of Dalton keywords!");
    return false;
  }

  regExp.setPattern("Generators=[123]{1}");
  n = regExp.indexIn(string(generalStringIndex_));
  if (n != -1)
  {
    setParseError(generalStringIndex_,
             "Generators keyword was found.\n\n"
             "Hint: QDalton 0.1 doesn't support generators!");
    return false;
  }

  regExp.setPattern("Angstrom");
  n = regExp.indexIn(string(generalStringIndex_));
  if (n != -1)
    setUnitOfLength(UnitOfLengthAngstrom);
  else
    setUnitOfLength(UnitOfLengthBohr);

  regExp.setPattern("Cartesian");
  n = regExp.indexIn(string(generalStringIndex_));
  if (n != -1)
    setGaussiansType(GaussiansTypeCartesian);
  else
    setGaussiansType(GaussiansTypeSpherical);

  regExp.setPattern("Charge=(\\d+)");
  n = regExp.indexIn(string(generalStringIndex_));
  if (n != -1)
    molecule().setCharge(regExp.cap(1).toInt(&ok));
  else
    molecule().setCharge(0);

  return true;
}

bool File::Mol::parseAtoms()
{
  bool ok;
  int i = generalStringIndex_;

  QRegExp regExp;

  regExp.setPattern("Charge=((\\d)(\\.\\d+)?)\\s+Atoms=(\\d+)(\\s+Basis=(.+)$)?");

  for (int a = 0; a < atomTypes(); a++)
  {
    i++;
    if (regExp.indexIn(string(i)) != -1)
    {
      int protons = regExp.cap(2).toInt(&ok);
      int count = regExp.cap(4).toInt(&ok);

      if (regExp.cap(5) != "")
      {
        hashBasisSets_[protons] = regExp.cap(6);
      }

      QRegExp regExpAtom("(\\w{1,4})\\s+(-?\\d?\\.\\d+)\\s+(-?\\d?\\.\\d+)\\s+(-?\\d?\\.\\d+)(\\s+Isotope=(\\d+))?");
      for (int j = 0; j < count; j++)
      {
        i++;
        quint8 isotope = 0;
        float x, y, z;
        if (regExpAtom.indexIn(string(i)) != -1)
        {
          x = regExpAtom.cap(2).toFloat(&ok);
          if (!ok)
          {
            // TODO error message
            return false;
          }

          y = regExpAtom.cap(3).toFloat(&ok);
          if (!ok)
          {
            // TODO error message
            return false;
          }

          z = regExpAtom.cap(4).toFloat(&ok);
          if (!ok)
          {
            // TODO error message
            return false;
          }

          if (unitOfLength() == UnitOfLengthBohr)
          {
            x = x * bohrsToAngstroms;
            y = y * bohrsToAngstroms;
            z = z * bohrsToAngstroms;
          }

          if (regExpAtom.cap(5) != "")
          {
            isotope = regExpAtom.cap(6).toInt(&ok);
            if (!ok)
            {
              // TODO error message
              return false;
            }
          }

          molecule().newAtom(protons, isotope, Eigen::Vector3f(x, y, z));
        }
      }
    }
  }
  return true;
}
